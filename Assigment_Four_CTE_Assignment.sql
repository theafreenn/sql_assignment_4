use mavenmovies;
-- Question 1)  Identify a table in the Sakila database that violates 1NF. Explain how you would normalize it to achieve 1NF
CREATE TABLE special_feature (
  feature_id INT AUTO_INCREMENT PRIMARY KEY,
  feature_name VARCHAR(255) NOT NULL
);

CREATE TABLE film_special_feature (
  film_id SMALLINT UNSIGNED NOT NULL,
  feature_id INT NOT NULL,
  PRIMARY KEY (film_id, feature_id),
  FOREIGN KEY (film_id) REFERENCES film (film_id) ON DELETE CASCADE ON UPDATE CASCADE,
  FOREIGN KEY (feature_id) REFERENCES special_feature (feature_id) ON DELETE CASCADE ON UPDATE CASCADE
);

ALTER TABLE film DROP COLUMN special_features;

-- Question 2) Choose a table in Sakila and describe how you would determine whether it is in 2NF. If it violates 2NF, explain the steps to normalize i
-- The primary key of the film table is the film_id. Let's check if there are any partial dependencies on the primary key.
-- Partial Dependency Check 
-- Columns that depend on the entire primary key (film_id) are title, description, release_year, rental_duration, rental_rate, length, replacement_cost, rating, special_features, and last_update.
-- Since all the non-prime attributes seem to be fully functionally dependent on the entire primary key (film_id), the film table appears to be in 2NF.
-- However, if there were columns that were dependent on only part of the primary key, we would need to decompose the table to remove partial dependencies.
-- Normalization steps to handle partial dependencies:
-- 1) Identify columns dependent on only part of the primary key.
-- 2) Create new tables for those dependent columns along with the part of the primary key they depend on.
-- 3) Link the new tables with foreign key constraints.

 -- Question 3) Identify a table in Sakila that violates 3NF. Describe the transitive dependencies present and outline the steps to normalize the table to 3NF
-- The column language_id is functionally dependent on the primary key film_id.
-- The column original_language_id is also functionally dependent on the primary key film_id.
-- Here, language_id and original_language_id are not functionally dependent on the entire primary key, but rather on part of it (film_id).
-- To bring the film table to 3NF, we need to eliminate these transitive dependencies.
-- Normalization Steps:

CREATE TABLE language (
  language_id TINYINT UNSIGNED NOT NULL PRIMARY KEY,
  original_language_id TINYINT UNSIGNED DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

ALTER TABLE film
DROP COLUMN language_id,
DROP COLUMN original_language_id;

ALTER TABLE film
ADD CONSTRAINT fk_film_language FOREIGN KEY (language_id) REFERENCES language (language_id) ON DELETE RESTRICT ON UPDATE CASCADE;

-- Question 4) Take a specific table in Sakila and guide through the process of normalizing it from the initial unnormalized form up to at least 2NF
-- The table is already in 1NF since each cell contains a single value, and there are no repeating groups.
-- In 2NF, we ensure that there are no partial dependencies on the primary key. The primary key for rental is (rental_id).
-- Looking at the table, it seems that return_date might be partially dependent on the primary key since it depends on rental_id but not on the entire primary key. To address this, we could create a new table for return_date and rental_id.
CREATE TABLE rental_return (
  rental_id INT NOT NULL,
  return_date DATETIME DEFAULT NULL,
  PRIMARY KEY (rental_id),
  CONSTRAINT fk_rental_return_rental FOREIGN KEY (rental_id) REFERENCES rental (rental_id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- Question 5) Write a query using a CTE to retrieve the distinct list of actor names and the number of films they have acted in from the actor and film_actor tables,
 With ActorFilmCount As (
 Select A.actor_id,
 concat(A.first_name, ' ', A.last_name) As Actor_Name,
 COUNT(FA.film_id) As Film_Count
 FROM actor A 
 inner join film_actor FA on A.actor_id = FA.actor_id 
 group by A.actor_id
 )
 Select actor_id, Actor_Name, Film_Count
 from ActorFilmCount;

-- Question 6) Use a recursive CTE to generate a hierarchical list of categories and their subcategories from the category table in Sakila
-- There are no sub category present in the whole database. So it is not possible to display hierarchical list based on category and subcategory

-- Question 7)  Create a CTE that combines information from the film and language tables to display the film title, language name, and rental rate.
With FilmInfo As ( 
Select f.title As film_title,
l.name As language_name,
f.rental_rate As rental_rate
From film f inner join language l on f.language_id = l.language_id
) 
Select film_title, language_name, rental_rate
From FilmInfo;

-- Question 8) Write a query using a CTE to find the total revenue generated by each customer (sum of payments) from the customer and payment tables.
With CustomerRevenue As (
Select c.customer_id,
concat(c.first_name, ' ', c.last_name) As customer_name,
sum(p.amount) As total_revenue
From customer c left join payment p on c.customer_id = p.customer_id
group by c.customer_id, customer_name
)
Select customer_id, customer_name,(total_revenue)
From CustomerRevenue;

-- Question 9) Utilize a CTE with a window function to rank films based on their rental duration from the film table.
With RankedFilm As (
Select film_id,
title,
rental_duration,
Rank () over(order by rental_duration desc) As rental_duration_rank
From film
)
Select film_id, title, rental_duration, rental_duration_rank
From RankedFilm;

-- Question 10) Create a CTE to list customers who have made more than two rentals, and then join this CTE with the customer table to retrieve additional customer details.
With CustomerRental As (
Select customer_id,
Count(*) As rental_count
From rental
group by customer_id
Having Count(*) > 2
)
Select c.*, CustomerRental.rental_count From customer c inner join CustomerRental on c.customer_id = CustomerRental.customer_id;

-- Question 11) Write a query using a CTE to find the total number of rentals made each month, considering the rental_date from rental table.
With MonthlyRentals As (
Select year(rental_date) As rental_year,
month(rental_date) As rental_month,
count(*) As total_rental
From rental
group by rental_year, rental_month
)
Select rental_year, rental_month, total_rental From 
MonthlyRentals
order by rental_year, rental_month;

-- Question 12)  Use a CTE to pivot the data from the payment table to display the total payments made by each customer in separate columns for different payment methods.
-- (Payment methods are not present in any table if payment method was present we could have use case and get the results)
WITH PaymentCTE AS (
SELECT
customer_id,
SUM(amount) AS total_payments
FROM
payment
GROUP BY
customer_id
)
SELECT * FROM PaymentCTE;
    
-- Question 13) Create a CTE to generate a report showing pairs of actors who have appeared in the same film together, using the film_actor table.
With ActorsPair As (
Select fa1.actor_id As actor1_id,
a1.first_name As actor1_first_name,
a1.last_name As Actor1_last_name,
fa2.actor_id As actor2_id,
a2.first_name As actor2_first_name,
a2.last_name As actor2_last_name,
f.film_id,
f.title As film_title
From film_actor fa1
inner join film f on fa1.film_id =f.film_id
inner join film_actor fa2 on fa1.film_id = fa2.film_id and fa1.actor_id < fa2.actor_id
inner join actor a1 on fa1.actor_id = a1.actor_id
inner join actor a2 on fa2.actor_id = a2.actor_id
)
Select * From ActorsPair;

 -- Question 14) Implement a recursive CTE to find all employees in the staff table who report to a specific manager, considering the reports_to column.
 -- ( There is no report_to column in any table where we specific the manager. But i have solved using manager_staff_id)
WITH RECURSIVE EmployeesHierarchy AS (
Select store_id, manager_staff_id
From store where manager_staff_id is not null
UNION 
Select s.store_id, s.manager_staff_id
From EmployeesHierarchy H
inner join store s on H.manager_staff_id = s.manager_staff_id
)
select * From EmployeesHierarchy H2
inner join staff st2 on st2.store_id = H2.manager_staff_id;
    
    
    
    
    
    
    